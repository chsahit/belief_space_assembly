"""
sketch:

make_graph(manip: WOs, env: WOs, X_WM: RT, X_WO: RT) -> cspace_graph:
    for each face on manip
        for each face on env
            compute minkowski sum

    for ea (A, B) in minkowski sums (order unimportant):
        if there is an intersection, connect

make_tp(graph) -> list[comntact modes]


types:
    A workspace object is a list of faces relative to a consistent frame with a label
    a cspace face is a polyhedron with a label (2d if coplanar, 3d if not?)
    - todo: prune "internal faces"
        - category 1: two cspace facets generated by same workspace object overlap
        - category 2: two cspace facets generated by different workspace objects overlap
    the cspace graph is (V, E) - with V being cspaces faces and E being the connections
"""

import itertools
from collections import dataclass

from pydrake.all import HPolyhedron, RigidTransform, VPolytope

import components


@dataclass
class WorkspaceObject:
    name: str
    geometry: HPolyhedron
    faces: Dict[str, HPolyhedron]


@dataclass
class CSpaceVolume:
    label: components.ContactState
    geometry: List[HPolyhedron]

    def intersects(self, other: CSpaceVolume) -> bool:
        for m_geom in self.geometry:
            for o_geom in other.geometry:
                if m_geom.IntersectsWith(o_geom):
                    return True
        return False

    def sample(self) -> np.ndarray:
        raise NotImplementedError


@dataclass
class CSpaceGraph:
    V: List[CSpaceVolume]
    E: List[Tuple[CSpaceVolume, CSpaceVolume]]

    def __str__(self) -> str:
        edge_strs = []
        for e in E:
            edge_strs.append(e[0].label, e[1].label)
        return edge_strs


def minkowski_sum(
    B_name: str, B: HPolyhedron, A_name: str, A: HPolyhedron
) -> CSpaceVolume:
    label = frozenset(((B_name, A_name),))
    B_vertices = GetVertices(B)
    A_vertices = GetVertices(A)
    volume_verts = []
    for vB in B_vertices:
        for vA in A_vertices:
            volume_verts.append(vB - vA)
    volume_verts = np.array(volume_verts)
    print(volume_verts.shape)
    breakpoint()
    volume_geometry = HPolyhedron(VPolytope(volume_verts))
    return CSpaceVolume(label, [volume_geometry])


def make_graph(
    manipuland: List[WorkspaceObject], env: List[WorkspaceObject]
) -> CSpaceGraph:
    volumes = []
    edges = []
    for manip_component in manipuland:
        for env_component in env:
            for manip_face in manip_component.faces.items():
                for env_face in env_component.faces.items():
                    vol = minkowski_sum(*env_component, *manip_component)
                    volumes.append(vol)
    for pair in itertools.combinations(volumes, 2):
        if pair[0].intersects(pair[1]):
            edges.append(pair)
    return CSpaceGraph(volumes, edges)


def make_task_plan(
    mode_graph: CSpaceGraph, start_mode: components.ContactState
) -> List[components.ContactState]:
    pass
