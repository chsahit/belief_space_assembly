"""
sketch:

make_graph(manip: WOs, env: WOs, X_WM: RT, X_WO: RT) -> cspace_graph:
    for each face on manip
        for each face on env
            compute minkowski sum

    for ea (A, B) in minkowski sums (order unimportant):
        if there is an intersection, connect

make_tp(graph) -> list[comntact modes]


types:
    A workspace object is a list of faces relative to a consistent frame with a label
    a cspace face is a polyhedron with a label (2d if coplanar, 3d if not?)
    - todo: prune "internal faces"
        - category 1: two cspace facets generated by same workspace object overlap
        - category 2: two cspace facets generated by different workspace objects overlap
    the cspace graph is (V, E) - with V being cspaces faces and E being the connections
"""

import itertools
import random
from collections import defaultdict
from dataclasses import dataclass
from typing import Dict, List, Tuple

import cdd
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
import plotly.graph_objects as go
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from pydrake.all import HPolyhedron, RandomGenerator, RigidTransform, VPolytope
from scipy.spatial import ConvexHull
from tqdm import tqdm

import components

drake_rng = RandomGenerator(0)


@dataclass
class WorkspaceObject:
    name: str
    geometry: HPolyhedron
    faces: Dict[str, HPolyhedron]


@dataclass
class CSpaceVolume:
    label: components.ContactState
    geometry: List[HPolyhedron]

    def intersects(self, other: "CSpaceVolume") -> bool:
        for m_geom in self.geometry:
            for o_geom in other.geometry:
                if m_geom.IntersectsWith(o_geom):
                    return True
        return False

    def sample(self) -> np.ndarray:
        raise NotImplementedError

    def is_strict_interior(self, pt) -> bool:
        # if point is exterior to all geometries, it cannot be strictly interior
        coarse_exterior_check = [not geom.PointInSet(pt) for geom in self.geometry]
        if all(coarse_exterior_check):
            return False
        # if point is strictly interior to any geometry, return true
        results = defaultdict(list)
        for direction in [0, 1, 2]:
            for delta in [0.0001, -0.0001]:
                pt_prime = np.copy(pt)
                pt_prime[direction] += delta
                for geom in self.geometry:
                    results[(direction, delta)].append(geom.PointInSet(pt_prime))
        for k, v in results.items():
            # we found a delta such that pt + delta is exterior
            # thus, the pt is a boundary pt
            if not any(v):
                return False
        return True

    def __eq__(self, other) -> bool:
        if not isinstance(other, CSpaceVolume):
            return False
        return self.label == other.label

    def __hash__(self) -> int:
        return hash(self.label)


@dataclass
class CSpaceGraph:
    V: List[CSpaceVolume]
    E: List[Tuple[CSpaceVolume, CSpaceVolume]]

    def __str__(self) -> str:
        edge_strs = []
        for e in self.E:
            edge_strs.append((e[0].label, e[1].label))
        return str(edge_strs)


def GetVertices(H: HPolyhedron, assert_count: bool = True) -> np.ndarray:
    V = VPolytope(H)
    vertices = V.vertices().T
    if vertices.shape[0] < 6:

        def MatToArr(m: cdd.Matrix) -> np.ndarray:
            return np.array([m[i] for i in range(m.row_size)])

        def HPolyhedronToVRepr(H: HPolyhedron) -> cdd.Matrix:
            print("CDD fallback")
            A, b = (H.A(), H.b())
            H_repr = np.hstack((np.array([b]).T, -A))
            mat = cdd.Matrix(H_repr, number_type="float")
            mat.rep_type = cdd.RepType.INEQUALITY
            poly = cdd.Polyhedron(mat)
            return poly.get_generators()

        vertices = MatToArr(HPolyhedronToVRepr(H))[:, 1:]

    if assert_count:
        if vertices.shape[0] < 6:
            breakpoint()
        assert vertices.shape == (8, 3) or vertices.shape == (6, 3)
    return vertices


def minkowski_sum(
    B_name: str, B: HPolyhedron, A_name: str, A: HPolyhedron
) -> CSpaceVolume:
    label = frozenset(((B_name, A_name),))
    B_vertices = GetVertices(B)
    A_vertices = GetVertices(A)
    volume_verts = []
    for vB_idx in range(B_vertices.shape[0]):
        for vA_idx in range(A_vertices.shape[0]):
            volume_verts.append(B_vertices[vB_idx] - A_vertices[vA_idx])
    volume_verts = np.array(volume_verts)
    volume_geometry = HPolyhedron(VPolytope(volume_verts.T))
    volume_geometry = volume_geometry.ReduceInequalities()
    return CSpaceVolume(label, [volume_geometry])


def MakeWorkspaceObjectFromFaces(
    faces: Dict[str, Tuple[np.ndarray, np.ndarray]]
) -> WorkspaceObject:
    faces_H = dict()
    for k, v in faces.items():
        if not is_face(k):
            faces_H[k] = HPolyhedron(*v)
    return WorkspaceObject("", None, faces_H)


def is_face(geom_name):
    suffixes = ["_bottom", "_top", "_left", "_right", "_front", "_back", "_inside"]

    is_badface = ("_top" in geom_name) and ("bottom_top" not in geom_name)
    is_chamfer = "chamfer" in geom_name
    # return any([suffix in geom_name for suffix in suffixes])
    if ("left_chamfer" in geom_name and not "inside" in geom_name) or (
        "Box" in geom_name and not "_" in geom_name
    ):
        print(f"{geom_name=}")
        return False
    else:
        return True
    # return any([suffix in geom_name for suffix in suffixes]) and (not is_badface)


def internal_edge(e: Tuple[CSpaceVolume, CSpaceVolume], cspace: CSpaceVolume) -> bool:
    assert len(e[0].geometry) == 1 and len(e[1].geometry) == 1
    intersection = e[0].geometry[0].Intersection(e[1].geometry[0])
    assert not intersection.IsEmpty()
    for i in range(15):
        try:
            samples = [
                intersection.UniformSample(drake_rng, intersection.ChebyshevCenter())
            ]
        except:
            samples = []
        if len(samples) > 0:
            break
    if len(samples) == 0:
        return False  # probably true, but we are being conservative in pruning
    for i in range(1000):
        samples.append(intersection.UniformSample(drake_rng, samples[-1]))

    for sample in samples:
        # this edge corresponds to an external edge on the CObs
        if not cspace.is_strict_interior(sample):
            return False
    return True


def prune_edges(
    cspace_volumes: List[CSpaceVolume],
    E: List[Tuple[CSpaceVolume, CSpaceVolume]],
) -> List[Tuple[CSpaceVolume, CSpaceVolume]]:
    all_volume_geometries = sum([vol.geometry for vol in cspace_volumes], [])
    print(f"{len(all_volume_geometries)=}")
    full_cspace = CSpaceVolume("", all_volume_geometries)
    plotly_render(full_cspace)
    return E
    pruned_edges = []
    for e in tqdm(E):
        if not internal_edge(e, full_cspace):
            pruned_edges.append(e)
    return pruned_edges


def prune_vertices(V: List[CSpaceVolume]) -> List[CSpaceVolume]:
    raise NotImplementedError
    to_remove = []
    for pair in itertools.combinations(V, 2):
        if is_subset(pair[0], pair[1]):
            to_remove.append(pair[0])
        elif is_subset(pair[1], pair[0]):
            to_remove.append(pair[1])
    pruned = []
    for v in V:
        if v not in to_remove:
            pruned.append(v)
    return pruned


def make_graph(
    manipuland: List[WorkspaceObject], env: List[WorkspaceObject]
) -> CSpaceGraph:
    volumes = []
    edges = []
    for manip_component in manipuland:
        for env_component in env:
            print(f"{len(manip_component.faces.items())=}")
            print(f"{len(env_component.faces.items())=}")
            for manip_face in manip_component.faces.items():
                for env_face in env_component.faces.items():
                    vol = minkowski_sum(*env_face, *manip_face)
                    volumes.append(vol)
    for pair in itertools.combinations(volumes, 2):
        if pair[0].intersects(pair[1]):
            edges.append(pair)
    print(f"pre-prune length: {len(edges)}")
    edges = prune_edges(volumes, edges)
    return CSpaceGraph(volumes, edges)


def label_to_str(label: components.ContactState) -> str:
    tag = ""
    for contact in label:
        A = contact[0][contact[0].find("::") + 2 :]
        B = contact[1][contact[1].find("::") + 2 :]
        tag += f"({A}, {B}), "
    return tag


def render_graph(g: CSpaceGraph, plotly: bool = True):
    nx_graph = nx.Graph()
    label_dict = dict()
    for e in g.E:
        nx_graph.add_edge(e[0], e[1])
        label_dict[e[0]] = label_to_str(e[0].label)
        label_dict[e[1]] = label_to_str(e[1].label)
    print(f"{nx.number_connected_components(nx_graph)=}")
    if not plotly:
        nx.draw(nx_graph, labels=label_dict, with_labels=True)
        plt.tight_layout()
        plt.savefig("mode_graph.png", bbox_inches="tight", dpi=300)
        return
    edge_x = []
    edge_y = []
    pos = nx.spring_layout(nx_graph)
    for edge in nx_graph.edges():
        x0, y0 = pos[edge[0]]
        x1, y1 = pos[edge[1]]
        edge_x.extend([x0, x1, None])
        edge_y.extend([y0, y1, None])
    edge_trace = go.Scatter(
        x=edge_x, y=edge_y, line=dict(width=0.5, color="#888"), mode="lines"
    )
    node_x = [pos[node][0] for node in nx_graph.nodes()]
    node_y = [pos[node][1] for node in nx_graph.nodes()]
    labels = [label_dict[node] for node in nx_graph.nodes()]
    node_trace = go.Scatter(
        x=node_x,
        y=node_y,
        mode="markers+text",
        hoverinfo="text",
        marker=dict(
            showscale=False,
            colorscale="YlGnBu",
            reversescale=True,
            color=[],
            size=10,
            line_width=2,
        ),
    )
    node_trace.text = labels
    fig = go.Figure(data=[edge_trace, node_trace])
    fig.update_layout(showlegend=False)
    fig.write_html("mode_graph.html")


def render_cspace_volume(C: CSpaceVolume):
    fig = plt.figure()
    ax = fig.add_subplot(111, projection="3d")
    colors = ["r", "g", "b", "black", "y", "p"]
    for i, geom in enumerate(C.geometry):
        vertices = GetVertices(geom, assert_count=False)
        try:
            hull = ConvexHull(vertices)
            color = colors[i % 3]
            for s in hull.simplices:
                tri = Poly3DCollection([vertices[s]])
                tri.set_color(color)
                # tri.set_alpha(0.5)
                ax.add_collection3d(tri)
        except:
            pass
    plt.show()


def plotly_render(C: CSpaceVolume):
    meshes = []
    for geom in C.geometry:
        vertices = GetVertices(geom, assert_count=False)
        try:
            hull = ConvexHull(vertices).simplices.T.tolist()
        except Exception as e:
            try:
                hull = ConvexHull(vertices, qhull_options="QJn").simplices.T.tolist()
            except:
                print("ignoring a hull")
                hull = None

        vertices = vertices.T.tolist()
        if hull is not None:
            meshes.append(
                go.Mesh3d(
                    x=vertices[0],
                    y=vertices[1],
                    z=vertices[2],
                    color="black",
                    opacity=1.0,
                    i=hull[0],
                    j=hull[1],
                    k=hull[2],
                )
            )

    print(f"{len(meshes)=}")
    fig = go.Figure(data=meshes)
    fig.write_html("cso.html")


def make_task_plan(
    mode_graph: CSpaceGraph, start_mode: components.ContactState
) -> List[components.ContactState]:
    pass
